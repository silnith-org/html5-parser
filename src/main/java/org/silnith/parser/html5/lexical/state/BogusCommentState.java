package org.silnith.parser.html5.lexical.state;

import static org.silnith.parser.util.UnicodeCodePoints.GREATER_THAN_SIGN;
import static org.silnith.parser.util.UnicodeCodePoints.NULL;
import static org.silnith.parser.util.UnicodeCodePoints.REPLACEMENT_CHARACTER;

import java.io.IOException;
import java.util.List;

import org.silnith.parser.html5.lexical.Tokenizer;
import org.silnith.parser.html5.lexical.token.CommentToken;
import org.silnith.parser.html5.lexical.token.Token;


/**
 * Applies the bogus comment state logic.
 * <p>
 * Consume every character up to and including the first ">" (U+003E) character or the end of the file (EOF), whichever comes first. Emit a comment token whose data is the concatenation of all the characters starting from and including the character that caused the state machine to switch into the bogus comment state, up to and including the character immediately before the last consumed character (i.e. up to the character just before the U+003E or EOF character), but with any U+0000 NULL characters replaced by U+FFFD REPLACEMENT CHARACTER characters. (If the comment was started by the end of the file (EOF), the token is empty. Similarly, the token is empty if it was generated by the string "<!>".)
 * <p>Switch to the data state.
 * <p>If the end of the file was reached, reconsume the EOF character.
 * 
 * @see org.silnith.parser.html5.lexical.Tokenizer.State#BOGUS_COMMENT
 * @see <a href="https://www.w3.org/TR/2014/REC-html5-20141028/syntax.html#bogus-comment-state">8.2.4.44 Bogus comment state</a>
 * @author <a href="mailto:silnith@gmail.com">Kent Rosenkoetter</a>
 */
public class BogusCommentState extends TokenizerState {
    
    public BogusCommentState(final Tokenizer tokenizer) {
        super(tokenizer);
    }
    
    @Override
    public int getMaxPushback() {
        return 0;
    }
    
    @Override
    public List<Token> getNextTokens() throws IOException {
        final StringBuilder content = new StringBuilder();
        int ch = consume();
        while (ch != EOF && ch != GREATER_THAN_SIGN) {
            if (ch == NULL) {
                content.append(REPLACEMENT_CHARACTER);
            } else {
                content.append(ch);
            }
            ch = consume();
        }
        setTokenizerState(Tokenizer.State.DATA);
        return one(new CommentToken(content.toString()));
    }
    
}
